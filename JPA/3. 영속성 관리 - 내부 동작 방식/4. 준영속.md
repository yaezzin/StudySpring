## 준영속

영속성 컨텍스트가 관리하는 여속 상태의 엔티티가 영속성 컨텍스트에서 분리된 것 
준영속 상태의 엔티티는 영속성 컨텍스트가 제공하는 기능을 사용할 수 없음

## 준영속 상태로 변경하는 방법 

#### 1. detach() : 특정 엔티티만

```java
// 비영속 상태
Member member = new Member();
member.setId("memberA");
member.setName("회원A");

// 영속상태
em.persist(member);

// 준영속 상태
em.detach(member);

transaction.commit();
```

* detach() 메서드를 호출하는 순간 1차 캐시부터 쓰기지연 SQL저장소까지 해당 엔티티를 관리하기 위한 모든 정보가 제거됨
* detach() 메서드에서 파라미터로 전달한 특정 엔티티만 준영속 상태로 변환함!

#### 2. clear() ; 초기화

em.detach()가 특정 엔티티 하나를 준영속 상태로 만들었다면 em.clear()는 영속성 컨텍스트를 초기화하여 모든 엔티티를 준영속 상태로 만듦

#### 3. close() : 종료

영속성 컨텍스트를 아예 종료하면 해당 영속성 컨텍스트가 관리하던 엔티티가 모두 준영속 상태가 됨  
주로 이 방식을 통해 준영속 상태가 되며, 개발자가 직접 준영속 상태로 만드는 일은 드묾

## 준영속 상태의 특징

```비영속에 가까움```  

: 영속성 컨텍스트가 관리하지 않으므로 1차캐시, 쓰기지연, 변경감지, 지연로딩 등.. 어떠한 기능도 동작하지 않음

```식별자 값을 가지고 있음```  

: 비영속 상태는 식별자 값이 없을 수 있으나 준영속 상태는 이미 영속상태였었기 떄문에 식별자 값을 가짐

```지연 로딩 불가능```  

: 지연록딩은 실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법  
: 하지만 준영속 상태는 영속성 상태의 관리를 벗어났기 떄문에 문제 발생 (이후에 설명하신다고 함)
